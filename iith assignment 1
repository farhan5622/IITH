import numpy as np
import matplotlib.pyplot as plt

# Transpose of a Matrix (as nested list)
a = [[1, 2, 3, 4], [2, 3, 4, 5]]
b = np.transpose(a)
print('a\n', a)
print('b\n', b)

# Transpose of a Matrix (as NumPy array)
print("Matrix and its Transpose")
a = np.array([[1, 2, 3, 4], [2, 3, 4, 5]])
b = a.T
print('a\n', a)
print('b\n', b)

# Scalars
a = 5
b = 3
z = np.dot(a, b)
print(z)

z = a * b
print(z)

# 1D arrays or vectors
a = np.array([1, 2, 3])
b = np.array([2, 3, 4])
z = np.dot(a, b)
print(z)

# 2D arrays or matrices
a = [[1, 2, 3], [2, 0, 3], [7, -5, 1]]
b = [[3, -1, 5], [-2, -6, 4], [0, 4, 4]]
z = np.dot(a, b)
print(z)

# Using np.matmul()
z = np.matmul(a, b)
print(z)

# Convert lists into NumPy arrays
newa = np.array(a)
newb = np.array(b)
z = newa.dot(newb)
print(z)

# Multiple matrix multiplication
a = np.random.randint(-4, 4, (500, 5))
b = np.random.randint(-4, 4, (5, 1000))
c = np.random.randint(-4, 4, (1000, 10))
d = np.random.randint(-4, 4, (10, 2000))
e = np.random.randint(-4, 4, (2000, 200))

# Perform multiple matrix multiplication
z = np.linalg.multi_dot([a, b, c, d, e])

# Measure CPU time for multi_dot
import time
start_time = time.time()
z = np.linalg.multi_dot([a, b, c, d, e])
print(z, '\n')
print("CPU time for multi_dot: %s seconds" % (time.time() - start_time))

# Measure CPU time for successive dot methods
start_time = time.time()
z = a.dot(b).dot(c).dot(d).dot(e)
print(z, '\n')
print("CPU time for successive dot methods: %s seconds" % (time.time() - start_time))

# Inner Product
a = np.array([[1, 2, 3], [4, -1, 0]])
b = np.array([6, 3, 2])
z = np.inner(a, b)
print(z)

# Using the dot method
print(a.dot(b.T))

# Outer Product
a = np.array([1, 2, 3, 4, 5])
b = np.array([6, 3, 2])
z = np.outer(a, b)
print(z)

# Matrix Determinant
a = np.random.randint(1, 10, [3, 3])
det = np.linalg.det(a)
print(int(det))

# Matrix Inverse
a = np.random.randint(1, 10, [3, 3])
inv = np.linalg.inv(a)
print(a)
print()
print(inv)

# Matrix Power
a = np.random.random([4, 4])
a_2 = np.linalg.matrix_power(a, 2)
a_7 = np.linalg.matrix_power(a, 7)
a_inv_1 = np.linalg.matrix_power(a, -1)
a_inv_3 = np.linalg.matrix_power(a, -3)
print('matrix \n', a)
print('\n matrix to the power 2\n', a_2)
print('\n matrix to the power 7\n', a_7)
print('\n matrix inverse \n', a_inv_1)
print('\n matrix cubic inverse \n', a_inv_3)

# Eigenvalues and Eigenvectors
a = np.arange(9).reshape(3, 3)
eig_val, eig_vec = np.linalg.eig(a)
print('Eigenvalues are: \n', eig_val)
print('\nEigenvectors are: \n', eig_vec)

# Eigenvalues alone
eigenvalues = np.linalg.eigvals(a)
print(eigenvalues)

# Traces of a Matrix
a = np.eye(5)
print(a)
z = np.trace(a)
print('\nTrace of matrix is: ', z)

# Matrix Norm
a = np.arange(12).reshape(4, 3)
z = np.linalg.norm(a)
print(a)
print('\n Frobenius Norm of above matrix:')
print(z)

# Norm along axis 0
a = np.arange(12).reshape(4, 3)
z = np.linalg.norm(a, axis=0)
print(z)

# Solving System of Equations
a = np.random.randint(1, 20, [4, 4])
b = np.array([4, 9, 12, 7])
x = np.linalg.solve(a, b)
print('Coefficient Matrix')
print(a)
print('\nDependent Variable vector')
print(b)
print('\nSolution')
print(x)

# Check for correctness
B = a.dot(x)
print(B)

# Singular Value Decomposition (SVD)
from skimage import data
image = data.astronaut()
print(image.dtype, image.min(), image.max(), image.shape)
plt.imshow(image)
plt.show()

# Normalize the image
img = image / 255.0
img = np.transpose(img, axes=(2, 0, 1))

# Perform SVD
U, S, V = np.linalg.svd(img)
print(U.shape, S.shape, V.shape)

# S matrix for reconstruction
Sigma = np.zeros((3, 512, 512))
for i in range(3):
    np.fill_diagonal(Sigma[i, :, :], S[i, :])
print(Sigma.shape)

# Reconstruct the original image
reconst = U @ Sigma @ V
reconst = np.transpose(reconst, axes=(1, 2, 0))
plt.imshow(reconst)
plt.show()

# Dimensionality reduction and reconstruction
k = 50
reconst = U @ Sigma[:, :, :k] @ V[:, :k, :]
reconst = np.transpose(reconst, axes=(1, 2, 0))
plt.imshow(reconst)
plt.show()

# Further reduction
k = 20
reconst = U @ Sigma[:, :, :k] @ V[:, :k, :]
reconst = np.transpose(reconst, axes=(1, 2, 0))
plt.imshow(reconst)
plt.show()

